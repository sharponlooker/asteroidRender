<!doctype html>
<html lang="en">
<head>
    <title>Asteroid Renderer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="css/base.css" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css" integrity="sha384-PsH8R72JQ3SOdhVi3uxftmaW6Vc51MKb0q5P2rRUpPvrszuE4W1povHYgTpBfshb" crossorigin="anonymous">
</head>
<body>

    <div class="main">
        <div class="row" style="height: 20%">
            <div class="col-2" id="statsContainer">
            </div>
            <div class="col-10">
                <canvas id="lightcurveChart" style="width: 75%; height: 95%;"></canvas>
            </div>
        </div>
        <div class="row" style="height: 80%">
            <div class="col-2">
                Tools
            </div>
            <div class="col-10" id="ThreeJS">
            </div>
        </div>
    </div>

    <script src="js/Three.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/Stats.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/KeyboardState.js"></script>
    <script src="js/THREEx.FullScreen.js"></script>
    <script src="js/THREEx.WindowResize.js"></script>
    <script src="js/Chart.min.js"></script>
    <script>
        const reducer = (accumulator, currentValue) => accumulator + currentValue;

        var CanvasViewModel = function (container, bodies, options) {
            var self = this;

            self.options = options || {};

            self.container = container;
            self.scene = new THREE.Scene();

            self.cameraPosition = options.cameraPosition || new THREE.Vector3(1000, 0, 0);

            self.bodies = bodies || [];

            self.frameListeners = options.frameListeners || [];

            self.init = function () {

                self.numberOfFrames = 0;
                var SCREEN_WIDTH = self.container.clientWidth, SCREEN_HEIGHT = self.container.clientHeight;
                var VIEW_ANGLE = 30, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;

                self.camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
                self.scene.add(self.camera);

                self.camera.position.set(self.cameraPosition.x, self.cameraPosition.y, self.cameraPosition.z);
                self.camera.lookAt(self.scene.position);

                if (Detector.webgl) {
                    self.renderer = new THREE.WebGLRenderer({ antialias: true });
                }
                else {
                    console.log('canvas renderer');
                    self.renderer = new THREE.CanvasRenderer();
                }

                self.renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

                // events
                THREEx.WindowResize(self.renderer, self.camera);
                THREEx.FullScreen.bindKey({ charCode: 'm'.charCodeAt(0) });

                self.controls = new THREE.OrbitControls(self.camera, self.renderer.domElement);

                if (self.options.statsContainer) {
                    var stats = new Stats();
                    stats.domElement.style.bottom = '0px';
                    stats.domElement.style.zIndex = 100;
                    statsContainer.appendChild(stats.domElement);

                    self.stats = stats;
                }

                self.setupLight();

                self.container.appendChild(self.renderer.domElement);
                self.webglContext = self.renderer.domElement.getContext('webgl');

                for (i = 0; i < self.bodies.length; i++) {
                    self.scene.add(self.bodies[i].mesh);
                }
            };

            self.setupLight = function () {

                self.light = new THREE.DirectionalLight(0xffffff, 1);
                self.light.position.set(0, 0, 10000);
                self.light.position.multiplyScalar(1.3);
                self.light.castShadow = true;

                self.light.shadow.mapSize.width = 1000;
                self.light.shadow.mapSize.length = 1000;
                self.light.shadow.camera.far = 1000;
                self.scene.add(self.light);
            };

            self.animate = function () {
                requestAnimationFrame(self.animate);
                self.render();
                self.controls.update();
                self.stats.update();
            };

            self.render = function () {
                for (i = 0; i < self.bodies.length; i++) {
                    self.bodies[i].render();
                }

                self.renderer.render(self.scene, self.camera);

                self.numberOfFrames++;

                if (0 == (self.numberOfFrames % 24)) {
                    self.frameListeners.forEach(function (listener) {
                        listener.newFrameCheckpoint(self); 
                    })
                }
            }

            self.init();
            self.animate();

            return self;
        };

        var LightcurveViewModel = function (container) {
            var self = this;

            self.t = 0;
            self.canvasWidth = 0;
            self.canvasHeight = 0;

            self.container = container;

            self.flux = [];

            self.canvasContext = self.container.getContext('2d');

            var chartConfig = {
                labels: [],
                datasets: [
                    {
                        label: 'Light curve',
                        fill: true,
                        lineTension: 0.1,
                        backgroundColor: 'rgba(75,192,192,0.4)',
                        borderColor: 'rgba(75,192,192,1)',
                        borderCapStyle: 'butt',
                        borderDash: [],
                        borderDashOffset: 0.0,
                        borderJoinStyle: 'miter',
                        pointBorderColor: 'rgba(75,192,192,1)',
                        pointBackgroundColor: '#fff',
                        pointBorderWidth: 1,
                        pointHoverRadius: 5,
                        pointHoverBackgroundColor: 'rgba(75,192,192,1)',
                        pointHoverBorderColor: 'rgba(220,220,220,1)',
                        pointHoverBorderWidth: 2,
                        pointRadius: 1,
                        pointHitRadius: 10,
                        data: [],
                        spanGaps: false,
                    }
                ]
            };

            self.chart = new Chart(self.canvasContext, {
                type: 'line',
                data: chartConfig,
                options: {
                    responsive: false,
                    scales: {
                        yAxes: [{
                            ticks: {
                                beginAtZero: false
                            }
                        }]
                    }
                }
            });

            self.newFrameCheckpoint = function (canvasViewModel) {
                var canvasContext = canvasViewModel.webglContext;

                if (!self.pixels
                    || self.canvasWidth != canvasContext.drawingBufferWidth
                    || self.canvasHeight != canvasContext.drawingBufferHeight
                ) {
                    self.canvasWidth = canvasContext.drawingBufferWidth;
                    self.canvasHeight = canvasContext.drawingBufferHeight;

                    self.pixels = new Uint8Array(canvasContext.drawingBufferWidth
                        * canvasContext.drawingBufferHeight
                        * 4);
                }

                canvasContext.readPixels(
                    0,
                    0,
                    canvasContext.drawingBufferWidth,
                    canvasContext.drawingBufferHeight,
                    canvasContext.RGBA,
                    canvasContext.UNSIGNED_BYTE,
                    self.pixels);

                var count = self.pixels.reduce(reducer) / 1000;

                /*if (self.chart.data.labels.length > 50) {
                    self.chart.data.labels.shift();
                    self.chart.data.datasets[0].data.shift();
                }*/

                self.chart.data.labels.push(self.t++);
                self.chart.data.datasets[0].data.push(count);
                self.chart.update();
                self.flux.push(count);
            };

            return self;
        };

        var Asteroid = function (asteroid) {
            var self = asteroid;

            self.texture = null;

            self.showAxis = asteroid.showAxis || false;

            self.rotationRate = asteroid.rotationRate || 0.001;

            self.axialTilt = (self.axialTilt || 0) * Math.PI / 180; // in radians

            self.scale = asteroid.scale || { a: 1.0, b: 1.0, c: 1.0 };

            self.geometry = new THREE.SphereGeometry(self.radius, 30, 30);
            self.geometry.applyMatrix(new THREE.Matrix4().makeScale(self.scale.a, self.scale.b, self.scale.c));

            self.rotationAxis = new THREE.Vector3(Math.sin(self.axialTilt), Math.cos(self.axialTilt), 0).normalize();
            //self.rotationAxis = new THREE.Vector3(10, 2, 5).normalize();

            if (self.textureFile) {
                self.texture = THREE.ImageUtils.loadTexture(self.textureFile);
            }

            if (self.showAxis) {
                var g = new THREE.Geometry();
                var delta = self.radius * 0.25;
                g.vertices = [
                    new THREE.Vector3(self.center.x,
                        (self.center.y - self.radius - delta) * self.scale.b,
                        self.center.z),
                    new THREE.Vector3(self.center.x,
                        (self.center.y + self.radius + delta) * self.scale.b,
                        self.center.z),
                ];

                self.axis = new THREE.Line(g,
                    new THREE.LineBasicMaterial({ color: 0xff0000 })
                );
                scene.add(self.axis);
            }

            self.material = new THREE.MeshLambertMaterial({
                color: 0xcccccc,
                map: self.texture,
            });

            self.material.opacity = 0.2;

            self.setup = function () {
                self.mesh = new THREE.Mesh(self.geometry, self.material);
                self.mesh.position.set(self.center.x, self.center.y, self.center.z);
                self.mesh.receiveShadow = true;
                self.mesh.castShadow = true;
            };

            self.render = function () {
                self.mesh.rotateOnAxis(self.rotationAxis, self.rotationRate);
            }

            self.setup();
            return self;
        };

        var bodies = [];
        bodies.push(new Asteroid({
            radius: 20,
            rotationRate: 0.008,
            center: new THREE.Vector3(10, 0, 0),
            showAxis: false,
            scale: { a: 10.0, b: 2.0, c: 3.0 },
            //textureFile: 'images/dirt-512.jpg',
        }));

        var lightcurveViewModel = new LightcurveViewModel(document.getElementById('lightcurveChart'));

        var canvasViewModel = new CanvasViewModel(
            document.getElementById('ThreeJS'),
            bodies,
            {
                statsContainer: document.getElementById('statsContainer'),
                frameListeners: [lightcurveViewModel],
            }
        );

        function init() {

            // HELPERS

            //scene.add(new THREE.AxesHelper(FAR));
            //scene.add(new THREE.CameraHelper(camera));
            //scene.add(new THREE.CameraHelper(sunLight.shadow.camera));

        }
    </script>

</body>
</html>
