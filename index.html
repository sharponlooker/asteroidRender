<!doctype html>
<html lang="en">
<head>
    <title>Asteroid Renderer</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel=stylesheet href="css/base.css" />
</head>
<body>

    <div id="ThreeJS" style="position: absolute; left:0px; top:0px"></div>

    <script src="js/Three.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/Stats.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script src="js/KeyboardState.js"></script>
    <script src="js/THREEx.FullScreen.js"></script>
    <script src="js/THREEx.WindowResize.js"></script>
    <script>
        const reducer = (accumulator, currentValue) => accumulator + currentValue;

        var CanvasViewModel = function (container, bodies, options) {

            options = options || {};

            self.container = container;
            self.scene = new THREE.Scene();

            self.flux = [];

            self.cameraPosition = options.cameraPosition || new THREE.Vector3(1000, 0, 0);

            self.bodies = bodies || [];

            self.init = function () {

                self.numberOfFrames = 0;
                var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
                var VIEW_ANGLE = 30, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;

                self.camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
                self.scene.add(self.camera);

                self.camera.position.set(self.cameraPosition.x, self.cameraPosition.y, self.cameraPosition.z);
                self.camera.lookAt(self.scene.position);

                if (Detector.webgl) {
                    console.log('webgl renderer');
                    self.renderer = new THREE.WebGLRenderer({ antialias: true });
                }
                else {
                    console.log('canvas renderer');
                    self.renderer = new THREE.CanvasRenderer();
                }

                self.renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

                // events
                THREEx.WindowResize(self.renderer, self.camera);
                THREEx.FullScreen.bindKey({ charCode: 'm'.charCodeAt(0) });

                self.controls = new THREE.OrbitControls(self.camera, self.renderer.domElement);

                self.setupLight();

                self.container.appendChild(renderer.domElement);
                self.webglContext = self.renderer.domElement.getContext('webgl');

                for (i = 0; i < self.bodies.length; i++) {
                    self.scene.add(self.bodies[i].mesh);
                }
            };

            self.setupLight = function () {

                self.light = new THREE.DirectionalLight(0xffffff, 1);
                self.light.position.set(0, 0, 10000);
                self.light.position.multiplyScalar(1.3);
                self.light.castShadow = true;

                self.light.shadow.mapSize.width = 1000;
                self.light.shadow.mapSize.length = 1000;
                self.light.shadow.camera.far = 1000;
                self.scene.add(self.light);
            };

            self.animate = function () {
                requestAnimationFrame(self.animate);
                self.render();
                self.controls.update();
                //self.stats.update();
            };

            self.render = function () {
                for (i = 0; i < self.bodies.length; i++) {
                    self.bodies[i].render();
                }

                self.renderer.render(self.scene, self.camera);

                self.numberOfFrames++;

                if (!self.pixels) {
                    self.pixels = new Uint8Array(self.webglContext.drawingBufferWidth * self.webglContext.drawingBufferHeight * 4);
                }

                if (0 == (self.numberOfFrames % 24)) {
                    self.webglContext.readPixels(
                        0,
                        0,
                        self.webglContext.drawingBufferWidth,
                        self.webglContext.drawingBufferHeight,
                        self.webglContext.RGBA,
                        self.webglContext.UNSIGNED_BYTE,
                        self.pixels);

                    self.flux.push(self.pixels.reduce(reducer));
                }
            }
            self.init();
            self.animate();

            return self;
        };

        var Asteroid = function (asteroid) {
            var self = asteroid;

            self.showAxis = asteroid.showAxis || false;

            self.rotationRate = asteroid.rotationRate || 0.001;

            self.axialTilt = (self.axialTilt || 0) * Math.PI / 180; // in radians

            self.scale = asteroid.scale || { a: 1.0, b: 1.0, c: 1.0 };

            self.geometry = new THREE.SphereGeometry(self.radius, 30, 30);
            self.geometry.applyMatrix(new THREE.Matrix4().makeScale(self.scale.a, self.scale.b, self.scale.c));

            self.rotationAxis = new THREE.Vector3(Math.sin(self.axialTilt), Math.cos(self.axialTilt), 0).normalize();
            //self.rotationAxis = new THREE.Vector3(10, 2, 5).normalize();

            if (self.showAxis) {
                var g = new THREE.Geometry();
                var delta = self.radius * 0.25;
                g.vertices = [
                    new THREE.Vector3(self.center.x,
                        (self.center.y - self.radius - delta) * self.scale.b,
                        self.center.z),
                    new THREE.Vector3(self.center.x,
                        (self.center.y + self.radius + delta) * self.scale.b,
                        self.center.z),
                ];

                self.axis = new THREE.Line(g,
                    new THREE.LineBasicMaterial({ color: 0xff0000 })
                );
                scene.add(self.axis);
            }

            self.material = new THREE.MeshLambertMaterial({ color: 0xcccccc });
            self.material.opacity = 0.2;

            self.setup = function () {
                self.mesh = new THREE.Mesh(self.geometry, self.material);
                self.mesh.position.set(self.center.x, self.center.y, self.center.z);
                self.mesh.receiveShadow = true;
                self.mesh.castShadow = true;
            };

            self.render = function () {
                self.mesh.rotateOnAxis(self.rotationAxis, self.rotationRate);
            }

            self.setup();
            return self;
        };

        var bodies = [];
        bodies.push(new Asteroid({
            radius: 20,
            rotationRate: 0.008,
            center: new THREE.Vector3(10, 0, 0),
            showAxis: false,
            scale: { a: 10.0, b: 2.0, c: 3.0 },
            //textureFile: 'images/dirt-512.jpg',
        }));

        var canvasViewModel = new CanvasViewModel(
            document.getElementById('ThreeJS'),
            bodies
        );

        function init() {
            // STATS
            stats = new Stats();
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.bottom = '0px';
            stats.domElement.style.zIndex = 100;
            //container.appendChild(stats.domElement);

            // HELPERS

            //scene.add(new THREE.AxesHelper(FAR));
            //scene.add(new THREE.CameraHelper(camera));
            //scene.add(new THREE.CameraHelper(sunLight.shadow.camera));

        }





    </script>

</body>
</html>
